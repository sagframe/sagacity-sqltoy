/**
 *@Generated by sagacity-quickvo 4.0
 */
package ${quickVO.voPackage};

import org.sagacity.sqltoy.config.annotation.SqlToyEntity;
<#if (quickVO.imports?exists && quickVO.imports?size>0)>
<#list quickVO.imports as import>
import ${import};
</#list>
</#if>
<#if (quickVO.exportTables?exists)>
import java.util.List;
</#if>
import ${quickVO.voPackage}.${quickVO.abstractPath}.Abstract${quickVO.voName};

/**
 * @project <#if (quickVO.projectName?exists)>${quickVO.projectName}</#if>
 * @author <#if (quickVO.author?exists)>${quickVO.author}</#if>
 * @version <#if (quickVO.version?exists)>${quickVO.version}</#if>
 * Table: ${quickVO.tableName}<#if (quickVO.tableRemark?exists && quickVO.tableRemark!='')>,Remark:${quickVO.tableRemark}</#if> 	
 */
@SqlToyEntity
public class ${quickVO.voName} extends Abstract${quickVO.voName} {	
	/**
	 * 
	 */
	private static final long serialVersionUID = ${quickVO.voSerialUID}L;
	
	/**
	 * 请绝对不要在此类中重复定义Abstract类中的对应表字段的属性,易导致属性失去@Column关联表字段的特征,无法正确生成相应的sql
	 * 如覆盖定义了属性C,原本生成 insert into tableName (A,B,C) values() 变成了 insert into tableName (A,B) values()
	 */
	 
	/** default constructor */
	public ${quickVO.voName}() {
		super();
	}
	
	/*---begin-constructor-area---don't-update-this-area--*/
<#if (quickVO.singlePk=='1'||quickVO.singlePk=='0')>
<#assign paramCnt="0"/> 
	/** pk constructor */
	public ${quickVO.voName}(<#list quickVO.columns as column><#if (column.pkFlag=='1')><#if (paramCnt=='1')>,</#if><#assign paramCnt='1'/>${column.resultType} ${column.colJavaName?uncap_first}</#if></#list>)
	{
		<#list quickVO.columns as column>
		<#if (column.pkFlag=='1')>
		this.${column.colJavaName?uncap_first}=${column.colJavaName?uncap_first};
		</#if>
		</#list>
	}
</#if>

<#if (quickVO.pkSizeEqualNotNullSize=='0' && quickVO.fullNotNull=='0')>	
<#assign paramCnt="0"/> 
	/** minimal constructor */
	public ${quickVO.voName}(<#list quickVO.columns as column><#if (column.nullable=='0')><#if (paramCnt=='1')>,</#if><#assign paramCnt='1'/>${column.resultType} ${column.colJavaName?uncap_first}</#if></#list>)
	{
		<#list quickVO.columns as column>
		<#if (column.nullable=='0')>
		this.${column.colJavaName?uncap_first}=${column.colJavaName?uncap_first};
		</#if>
		</#list>
	}
</#if>

<#if (quickVO.pkIsAllColumn=='0')>
<#assign paramCnt="0"/>	
	/** full constructor */
	public ${quickVO.voName}(<#list quickVO.columns as column><#if (paramCnt=='1')>,</#if><#assign paramCnt='1'/>${column.resultType} ${column.colJavaName?uncap_first}</#list>)
	{
		<#list quickVO.columns as column>
		this.${column.colJavaName?uncap_first}=${column.colJavaName?uncap_first};
		</#list>
	}
</#if>

<#if (quickVO.exportTables?exists)>
<#list quickVO.exportTables as exportTable>
	/**
	 * mapping ${exportTable.pkRefTableName} data to ${quickVO.tableName} oneToMany List
	 */
	public void mapping${exportTable.pkRefTableJavaName?cap_first}<#if exportTable.pkRefTableJavaName?ends_with("s")>e</#if>s(List<${quickVO.voName}> mainSet,List<${exportTable.pkRefTableJavaName?cap_first}> itemSet)
    {
    	if(mainSet==null || mainSet.isEmpty() || itemSet==null||itemSet.isEmpty())
    		return;
    	${quickVO.voName} main;
    	${exportTable.pkRefTableJavaName?cap_first} item;
    	for(int i=0;i<mainSet.size();i++){
    		main=mainSet.get(i);
    		if(itemSet.size()==0)
    			break;
    		for(int j=0;j<itemSet.size();j++){
    			item=itemSet.get(j);
    			if(${exportTable.pkEqualsFkStr}){
    			  main.${exportTable.pkRefTableJavaName?uncap_first}<#if exportTable.pkRefTableJavaName?ends_with("s")>e</#if>s.add(item);
    			  itemSet.remove(j);
    			  j--;
    			}
    		}
    	}
    }
</#list>
</#if>
	/*---end-constructor-area---don't-update-this-area--*/
	
	/**
     *@todo vo columns to String
     */
	public String toString() {
		return super.toString();
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#clone()
	 */
	public ${quickVO.voName} clone() {
		try {
			// TODO Auto-generated method stub
			return (${quickVO.voName}) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return null;
	}
	
}